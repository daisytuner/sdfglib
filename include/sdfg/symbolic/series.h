/**
 * @file series.h
 * @brief Analysis of symbolic series and sequences
 *
 * This file provides functions for analyzing symbolic expressions that represent
 * series or sequences, particularly those generated by loop induction variables.
 * These analyses are useful for:
 * - Determining memory access patterns in loops
 * - Optimizing loop transformations
 * - Vectorization opportunities
 * - Prefetching and caching strategies
 *
 * ## Series Analysis
 *
 * When a symbol evolves according to a map (e.g., a loop induction variable),
 * it generates a series of values. This module provides functions to analyze
 * the properties of such series:
 * - **Affine coefficients**: Extracting stride and offset for linear series
 * - **Monotonicity**: Whether the series is increasing or decreasing
 * - **Contiguity**: Whether the series generates consecutive values
 *
 * ## Example Usage
 *
 * @code
 * // Analyze the series generated by A[2*i + 3] where i goes 0, 1, 2, ...
 * auto i = symbolic::symbol("i");
 * auto expr = symbolic::add(symbolic::mul(symbolic::integer(2), i), symbolic::integer(3));
 * 
 * Assumptions assums;
 * assums[i].add_lower_bound(symbolic::zero());
 * assums[i].add_upper_bound(symbolic::integer(10));
 * assums[i].map(symbolic::add(i, symbolic::one()));  // i evolves as i' = i + 1
 * 
 * auto [is_affine, coeffs] = affine_int_coeffs(expr, i, assums);
 * // is_affine = true, coeffs = (2, 3) meaning stride=2, offset=3
 * 
 * bool mono = is_monotonic(expr, i, assums);  // true (increases by 2 each step)
 * bool contig = is_contiguous(expr, i, assums);  // false (jumps by 2, not consecutive)
 * @endcode
 *
 * @see maps.h for related map analysis functions
 * @see assumptions.h for symbol assumptions and evolution maps
 */

#pragma once

#include "sdfg/symbolic/assumptions.h"
#include "sdfg/symbolic/symbolic.h"

namespace sdfg {
namespace symbolic {
namespace series {

/**
 * @brief Extracts affine coefficients from an expression
 * @param expr Expression to analyze (should be affine in sym)
 * @param sym Symbol to analyze with respect to
 * @param assums Assumptions about symbols
 * @return Pair of (is_affine, (stride, offset)) where is_affine indicates success
 *
 * Attempts to represent the expression as an affine function of the symbol:
 *   expr = stride * sym + offset
 * where stride and offset are integers.
 *
 * This is useful for analyzing memory access patterns. For example, A[2*i + 3]
 * has stride=2 and offset=3, indicating accesses are spaced 2 elements apart
 * starting at index 3.
 *
 * @code
 * auto [is_affine, coeffs] = affine_int_coeffs(expr, i, assums);
 * if (is_affine) {
 *     auto [stride, offset] = coeffs;
 *     // Use stride and offset for optimization
 * }
 * @endcode
 */
std::pair<bool, std::pair<Integer, Integer>>
affine_int_coeffs(const Expression expr, const Symbol sym, const Assumptions& assums);

/**
 * @brief Checks if an expression is monotonic as a symbol evolves
 * @param expr Expression to check
 * @param sym Symbol that evolves
 * @param assums Assumptions including evolution map for sym
 * @return true if expr is monotonically increasing or decreasing as sym evolves
 *
 * Determines if the expression consistently increases or decreases as the symbol
 * evolves according to its map. This is useful for determining if memory accesses
 * proceed in a consistent direction, which can enable optimizations like prefetching.
 *
 * @code
 * // Check if 2*i is monotonic when i goes 0, 1, 2, ...
 * bool mono = is_monotonic(expr, i, assums);  // true
 * @endcode
 */
bool is_monotonic(const Expression expr, const Symbol sym, const Assumptions& assums);

/**
 * @brief Checks if an expression generates contiguous values
 * @param expr Expression to check
 * @param sym Symbol that evolves
 * @param assums Assumptions including evolution map for sym
 * @return true if expr generates consecutive integer values as sym evolves
 *
 * Determines if the series of values generated by the expression are contiguous
 * (consecutive integers with no gaps). This is important for vectorization and
 * memory coalescing optimizations.
 *
 * For example:
 * - i+0, i+1, i+2, ... is contiguous (stride = 1)
 * - 2*i+0, 2*i+2, 2*i+4, ... is not contiguous (stride = 2)
 *
 * @code
 * // Check if i generates contiguous values (yes)
 * bool contig1 = is_contiguous(i, i, assums);  // true
 * 
 * // Check if 2*i generates contiguous values (no, stride=2)
 * bool contig2 = is_contiguous(mul(integer(2), i), i, assums);  // false
 * @endcode
 */
bool is_contiguous(const Expression expr, const Symbol sym, const Assumptions& assums);

} // namespace series
} // namespace symbolic
} // namespace sdfg
